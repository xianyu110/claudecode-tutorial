# 27.4 程式碼質量評估與提升

## 程式碼質量評估概述

Claude Code 可以幫助開發者全面評估程式碼質量，並提供具體的改進建議。透過系統化的質量評估和持續的程式碼改進，開發者可以構建更健壯、可維護的程式碼庫。

## 代码质量指标

### 1\. 可读性评估

# 示例：评估代码可读性


使用者請求： "評估這段程式碼的可讀性"

Claude Code 生成的評估報告：

```python
## 代码可读性评估

### 待评估代码

    python


    ````python

    | 指标 | 得分 | 满分 | 等级 |
    |------|------|------|------|
    | 命名规范 | 2/10 | 10 | 差 |
    | 函数长度 | 8/10 | 10 | 良好 |
    | 注释覆盖 | 0/10 | 10 | 差 |
    | 代码格式 | 5/10 | 10 | 中等 |
    | 复杂度 | 9/10 | 10 | 优秀 |
    | **总分** | **24/50** | **50** | **差** |

    ### 问题分析

    1. **命名不规范**:

     - 函数名 `f` 不具有描述性
     - 参数名 `x`, `y`, `z` 不清晰
     - 变量名 `r` 不明确

    2. **缺少注释**:

     - 没有函数文档字符串
     - 没有行内注释说明逻辑

    3. **格式不规范**:

     - 缺少空格分隔
     - 缩进不一致

    ### 改进建议

    python

    # 示例：评估代码可维护性

    用户请求：
    "评估这段代码的可维护性"

    Claude Code 生成的评估报告：

    ## 代码可维护性评估

    ### 待评估代码

    class OrderProcessor:
        def process(self, data):
            if data['type'] == 'new':
                if data['payment'] == 'credit_card':
                    if data['card']['type'] == 'visa':
                        self.process_visa(data)
                    elif data['card']['type'] == 'mastercard':
                        self.process_mastercard(data)
                    elif data['card']['type'] == 'amex':
                        self.process_amex(data)
                elif data['payment'] == 'paypal':
                    self.process_paypal(data)
                elif data['payment'] == 'bank_transfer':
                    self.process_bank_transfer(data)
            elif data['type'] == 'update':
                self.process_update(data)
            elif data['type'] == 'cancel':
                self.process_cancel(data)

    ### 可维护性评分

    | 指标 | 得分 | 满分 | 等级 |
    |------|------|------|------|
    | 模块化 | 3/10 | 10 | 差 |
    | 扩展性 | 2/10 | 10 | 差 |
    | 耦合度 | 4/10 | 10 | 差 |
    | 内聚性 | 6/10 | 10 | 中等 |
    | 测试性 | 3/10 | 10 | 差 |
    | **总分** | **18/50** | **50** | **差** |

    ### 问题分析

    1. **模块化程度低**:

     - 所有逻辑集中在一个方法中
     - 缺少清晰的职责划分

    2. **扩展性差**:

     - 添加新的订单类型需要修改现有代码
     - 添加新的支付方式需要修改现有代码

    3. **高耦合**:

     - 订单处理与支付处理紧密耦合
     - 难以独立测试各个部分

    4. **测试困难**:

     - 需要模拟大量场景
     - 难以隔离测试各个分支

    ### 改进建议

    from abc import ABC, abstractmethod

    class OrderType(ABC):
    """訂單型別基類"""

    @abstractmethod
    def process(self, data):
    """處理訂單"""
    pass

    class NewOrder(OrderType):
    """新訂單"""

    def __init__(self, payment_processor):
    self.payment_processor = payment_processor

    def process(self, data):
    """處理新訂單"""
    return self.payment_processor.process(data['payment'], data)

    class UpdateOrder(OrderType):
    """更新訂單"""

    def process(self, data):
    """處理訂單更新"""
    return self.process_update(data)

    def process_update(self, data):
    """更新訂單邏輯"""
    pass

    class CancelOrder(OrderType):
    """取消訂單"""

    def process(self, data):
    """處理訂單取消"""
    return self.process_cancel(data)

    def process_cancel(self, data):
    """取消訂單邏輯"""
    pass

    class PaymentProcessor(ABC):
    """支付處理器基類"""

    @abstractmethod
    def process(self, payment_type, data):
    """處理支付"""
    pass

    class CreditCardPayment(PaymentProcessor):
    """信用卡支付"""

    def __init__(self):
    self.card_processors = {
    'visa': self.process_visa,
    'mastercard': self.process_mastercard,
    'amex': self.process_amex
    }

    def process(self, payment_type, data):
    """處理信用卡支付"""
    card_type = data['card']['type']
    processor = self.card_processors.get(card_type)

    if not processor:
    raise ValueError(f"Unsupported card type: {card_type}")

    return processor(data)

    def process_visa(self, data):
    """處理 Visa 卡"""
    pass

    def process_mastercard(self, data):
    """處理萬事達卡"""
    pass

    def process_amex(self, data):
    """處理美國運通卡"""
    pass

    class PayPalPayment(PaymentProcessor):
    """PayPal 支付"""

    def process(self, payment_type, data):
    """處理 PayPal 支付"""
    return self.process_paypal(data)

    def process_paypal(self, data):
    """PayPal 支付邏輯"""
    pass

    class BankTransferPayment(PaymentProcessor):
    """銀行轉賬"""

    def process(self, payment_type, data):
    """處理銀行轉賬"""
    return self.process_bank_transfer(data)

    def process_bank_transfer(self, data):
    """銀行轉賬邏輯"""
    pass

    class OrderProcessor:
    """訂單處理器"""

    def __init__(self):
    self.order_types = {
    'new': NewOrder(self._create_payment_processor()),
    'update': UpdateOrder(),
    'cancel': CancelOrder()
    }

    def _create_payment_processor(self):
    """建立支付處理器"""
    payment_processors = {
    'credit_card': CreditCardPayment(),
    'paypal': PayPalPayment(),
    'bank_transfer': BankTransferPayment()
    }
    return PaymentProcessorFactory(payment_processors)

    def process(self, data):
    """處理訂單"""
    order_type = data['type']
    processor = self.order_types.get(order_type)

    if not processor:
    raise ValueError(f"Unsupported order type: {order_type}")

    return processor.process(data)

    ```### 改进后评分

    | 指标 | 改进前 | 改进后 | 改善 |
    |------|--------|--------|------|
    | 模块化 | 3/10 | 10/10 | +233% |
    | 扩展性 | 2/10 | 10/10 | +400% |
    | 耦合度 | 4/10 | 9/10 | +125% |
    | 内聚性 | 6/10 | 10/10 | +67% |
    | 测试性 | 3/10 | 10/10 | +233% |
    | **总分** | **18/50** | **49/50** | **+172%** |

    ```

    ## 程式碼質量提升

    ### 1. 重構策略

    # 示例：程式碼重構

    使用者請求：
    "重構這段程式碼以提高質量"
    Claude Code 生成的重構方案：

    ## 程式碼重構

    ### 原始程式碼

    ````python
    `python

    def calculate_price(product, quantity, discount_code, shipping_method, customer_level):
    price = product['price'] * quantity

    if discount_code == 'SAVE10':
    price *= 0.9
    elif discount_code == 'SAVE20':
    price *= 0.8
    elif discount_code == 'SAVE30':
    price *= 0.7

    if shipping_method == 'standard':
    price += 5
    elif shipping_method == 'express':
    price += 10
    elif shipping_method == 'overnight':
    price += 20

    if customer_level == 'gold':
    price *= 0.95
    elif customer_level == 'platinum':
    price *= 0.9

    return price

    ```### 重構步驟

    #### 步驟 1: 提取折扣策略

    ```
    python

    class DiscountStrategy:
        """折扣策略"""

        DISCOUNTS = {
            'SAVE10': 0.9,
            'SAVE20': 0.8,
            'SAVE30': 0.7
        }

        @classmethod
        def apply_discount(cls, price, discount_code):
            """应用折扣"""
            discount = cls.DISCOUNTS.get(discount_code, 1.0)
            return price * discount

    #### 步骤 2: 提取运费策略

    ````python

    ````python

    def calculate_price(product, quantity, discount_code, shipping_method, customer_level):
    """
    计算商品价格

    参数:
    product: 商品信息
    quantity: 数量
    discount_code: 折扣码
    shipping_method: 配送方式
    customer_level: 客户等级

    返回:
    最终价格
    """
     # 计算基础价格
    base_price = product['price'] * quantity

     # 应用折扣
    discounted_price = DiscountStrategy.apply_discount(
    base_price,
    discount_code
    )

     # 添加运费
    price_with_shipping = discounted_price + ShippingStrategy.calculate_shipping(
    shipping_method
    )

     # 应用客户等级折扣
    final_price = CustomerLevelStrategy.apply_level_discount(
    price_with_shipping,
    customer_level
    )

    return final_price

    ```### 重構效果

    | 指標 | 改進前 | 改進後 | 改善 |
    |------|--------|--------|------|
    | 圈複雜度 | 9 | 1 | 89% ↓ |
    | 可讀性 | 5/10 | 9/10 | +80% |
    | 可測試性 | 3/10 | 10/10 | +233% |
    | 可擴充套件性 | 2/10 | 9/10 | +350% |

    ```
    ### 2. 性能优化

    # 示例：性能优化
    用户请求：
    "优化这段代码的性能"
    Claude Code 生成的优化方案：
    ## 性能优化
    ### 原始代码

    ````python

    `python

    def find_duplicate_products(products):
    """查詢重複商品"""
    duplicates = []

    for i, product1 in enumerate(products):
    for j, product2 in enumerate(products):
    if i != j and product1['name'] == product2['name']:
    duplicates.append({
    'product1': product1,
    'product2': product2
    })

    return duplicates

    ```### 性能分析

    | 指标 | 值 |
    |------|-----|
    | 时间复杂度 | O(n²) |
    | 空间复杂度 | O(n) |
    | 执行时间 (1000 项) | 500ms |
    | 执行时间 (10000 项) | 50000ms |

    ### 优化方案

    ```

    python

    def find_duplicate_products(products):
        """
        查詢重複商品（最佳化後）

        使用字典來跟蹤已見過的商品，將時間複雜度從 O(n²) 降低到 O(n)
        """
        product_map = {}
        duplicates = []

        for product in products:
            name = product['name']

            if name in product_map:

                # 找到重複

                for existing_product in product_map[name]:
                    duplicates.append({
                        'product1': existing_product,
                        'product2': product
                    })
                product_map[name].append(product)
            else:
                product_map[name] = [product]

        return duplicates

    ### 進一步最佳化（使用集合）

    ````python

    ````python

    def find_duplicate_products(products):
    """
    查詢重複商品（進一步最佳化）

    使用集合來快速判斷重複
    """
    seen = set()
    duplicates = []

    for product in products:
    name = product['name']

    if name in seen:
    duplicates.append(product)
    else:
    seen.add(name)

    return duplicates

    ```### 优化效果

    | 指标 | 原始 | 优化 1 | 优化 2 |
    |------|------|--------|--------|
    | 时间复杂度 | O(n²) | O(n) | O(n) |
    | 空间复杂度 | O(n) | O(n) | O(n) |
    | 执行时间 (1000 项) | 500ms | 5ms | 3ms |
    | 执行时间 (10000 项) | 50000ms | 50ms | 30ms |
    | 性能提升 | - | 99% ↓ | 99.4% ↓ |

    ```

    ## 程式碼質量檢查清單

    ### 1. 程式碼風格

    - [ ] 遵循 PEP 8 (Python) 或相應的語言規範
    - [ ] 使用一致的命名約定
    - [ ] 新增適當的註釋和文件字串
    - [ ] 保持程式碼格式一致

    ### 2. 程式碼結構

    - [ ] 函式和類職責單一
    - [ ] 避免過長的函式和類
    - [ ] 合理使用設計模式
    - [ ] 保持低耦合高內聚

    ### 3. 錯誤處理

    - [ ] 適當的異常處理
    - [ ] 有意義的錯誤訊息
    - [ ] 資源正確釋放
    - [ ] 邊界條件處理

    ### 4. 效能

    - [ ] 避免不必要的計算
    - [ ] 使用適當的資料結構
    - [ ] 避免記憶體洩漏
    - [ ] 最佳化資料庫查詢

    ### 5. 安全

    - [ ] 輸入驗證
    - [ ] 防止 SQL 注入
    - [ ] 防止 XSS 攻擊
    - [ ] 敏感資料保護

    ### 6. 測試

    - [ ] 單元測試覆蓋
    - [ ] 整合測試
    - [ ] 邊界測試
    - [ ] 效能測試

    ## 總結

    程式碼質量評估與提升包括：

    1. **程式碼質量指標**: 可讀性、可維護性、效能
    2. **重構策略**: 提取方法、應用設計模式、簡化邏輯
    3. **效能最佳化**: 演算法最佳化、資料結構最佳化、快取策略
    4. **質量檢查清單**: 程式碼風格、結構、錯誤處理、效能、安全、測試

    透過系統化的質量評估和持續的程式碼改進，開發者可以構建更健壯、可維護的程式碼庫。

    在下一節中，我們將探討跨語言程式碼生成與理解。

    ```

    ```

```

```
