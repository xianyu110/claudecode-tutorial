# 18.2 ä»£ç å®¡æŸ¥æŠ€èƒ½

## ä»£ç å®¡æŸ¥æŠ€èƒ½æ¦‚è¿°

ä»£ç å®¡æŸ¥æŠ€èƒ½æ˜¯ Claude Code Skills ä¸­ç”¨äºè‡ªåŠ¨åŒ–ä»£ç å®¡æŸ¥çš„é‡è¦å·¥å…·ã€‚å®ƒå¯ä»¥å¸®åŠ©å¼€å‘è€…å¿«é€Ÿè¯†åˆ«ä»£ç ä¸­çš„é—®é¢˜ï¼Œæé«˜ä»£ç è´¨é‡å’Œå¯ç»´æŠ¤æ€§ã€‚

```python
## å®¡æŸ¥ç±»å‹

### 1\. é™æ€ä»£ç åˆ†æ

#### 1.1 ä»£ç è´¨é‡æ£€æŸ¥

    python


    # src/skills/code_reviewer.py
    from typing import Dict, Any, List
    from claude_code_sdk import Skill, SkillContext, SkillResult
    import re

    class CodeReviewerSkill(Skill):
        """ä»£ç å®¡æŸ¥æŠ€èƒ½"""

        def __init__(self):
            super().__init__(
                name="code-reviewer",
                version="1.0.0",
                description="Automated code review skill"
            )

            # å®šä¹‰å®¡æŸ¥è§„åˆ™
            self.rules = {
                "naming": self.check_naming_conventions,
                "complexity": self.check_complexity,
                "security": self.check_security,
                "performance": self.check_performance,
                "documentation": self.check_documentation
            }

        def get_parameters_schema(self) -> Dict[str, Any]:
            return {
                "type": "object",
                "properties": {
                    "file_path": {
                        "type": "string",
                        "description": "Path to the file to review"
                    },
                    "code": {
                        "type": "string",
                        "description": "Code to review (alternative to file_path)"
                    },
                    "language": {
                        "type": "string",
                        "enum": ["python", "javascript", "java", "go"],
                        "description": "Programming language"
                    },
                    "rules": {
                        "type": "array",
                        "description": "Rules to apply",
                        "items": {
                            "type": "string",
                            "enum": ["naming", "complexity", "security", "performance", "documentation"]
                        }
                    },
                    "severity": {
                        "type": "string",
                        "enum": ["all", "error", "warning", "info"],
                        "description": "Minimum severity level"
                    }
                },
                "required": ["language"]
            }

        def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
            try:
                language = parameters["language"]
                rules_to_apply = parameters.get("rules", list(self.rules.keys()))
                severity = parameters.get("severity", "all")

                # è·å–ä»£ç 
                if "file_path" in parameters:
                    code = context.read_file(parameters["file_path"])
                    file_path = parameters["file_path"]
                elif "code" in parameters:
                    code = parameters["code"]
                    file_path = "<inline>"
                else:
                    return SkillResult(
                        success=False,
                        error="Either file_path or code must be provided"
                    )

                # æ‰§è¡Œå®¡æŸ¥
                issues = []
                for rule_name in rules_to_apply:
                    if rule_name in self.rules:
                        rule_func = self.rules[rule_name]
                        rule_issues = rule_func(code, language)
                        issues.extend(rule_issues)

                # è¿‡æ»¤ä¸¥é‡æ€§
                if severity != "all":
                    severity_levels = {"error": 3, "warning": 2, "info": 1}
                    min_level = severity_levels.get(severity, 0)
                    issues = [
                        issue for issue in issues
                        if severity_levels.get(issue["severity"], 0) >= min_level
                    ]

                # ç”ŸæˆæŠ¥å‘Š
                report = self.generate_report(code, issues, file_path)

                return SkillResult(
                    success=True,
                    data={
                        "file_path": file_path,
                        "language": language,
                        "rules_applied": rules_to_apply,
                        "issues": issues,
                        "issue_count": len(issues),
                        "report": report
                    }
                )
            except Exception as e:
                return SkillResult(
                    success=False,
                    error=str(e)
                )

        def check_naming_conventions(self, code: str, language: str) -> List[Dict]:
            """æ£€æŸ¥å‘½åè§„èŒƒ"""
            issues = []

            if language == "python":
                # æ£€æŸ¥å‡½æ•°åï¼ˆåº”è¯¥æ˜¯ snake_caseï¼‰
                func_pattern = r'def\s+([A-Z][a-zA-Z0-9_]*)\s*\('
                for match in re.finditer(func_pattern, code):
                    line_num = code[:match.start()].count('\n') + 1
                    issues.append({
                        "type": "naming",
                        "severity": "warning",
                        "line": line_num,
                        "message": f"Function name '{match.group(1)}' should use snake_case",
                        "suggestion": match.group(1).lower()
                    })

                # æ£€æŸ¥ç±»åï¼ˆåº”è¯¥æ˜¯ CamelCaseï¼‰
                class_pattern = r'class\s+([a-z][a-zA-Z0-9_]*)\s*[:\(]'
                for match in re.finditer(class_pattern, code):
                    line_num = code[:match.start()].count('\n') + 1
                    issues.append({
                        "type": "naming",
                        "severity": "warning",
                        "line": line_num,
                        "message": f"Class name '{match.group(1)}' should use CamelCase",
                        "suggestion": match.group(1).title()
                    })

            elif language == "javascript":
                # æ£€æŸ¥å¸¸é‡ï¼ˆåº”è¯¥æ˜¯ UPPER_CASEï¼‰
                const_pattern = r'const\s+([a-z][a-zA-Z0-9_]*)\s*='
                for match in re.finditer(const_pattern, code):
                    line_num = code[:match.start()].count('\n') + 1
                    issues.append({
                        "type": "naming",
                        "severity": "info",
                        "line": line_num,
                        "message": f"Constant '{match.group(1)}' should use UPPER_CASE",
                        "suggestion": match.group(1).upper()
                    })

            return issues

        def check_complexity(self, code: str, language: str) -> List[Dict]:
            """æ£€æŸ¥å¤æ‚åº¦"""
            issues = []
            lines = code.split('\n')

            for i, line in enumerate(lines, 1):
                # è®¡ç®—ç¼©è¿›çº§åˆ«
                indent = len(line) - len(line.lstrip())

                # æ£€æŸ¥è¿‡æ·±çš„åµŒå¥—
                if indent > 24:
                    issues.append({
                        "type": "complexity",
                        "severity": "warning",
                        "line": i,
                        "message": f"Deep nesting detected (indent level: {indent // 4})",
                        "suggestion": "Consider refactoring to reduce nesting"
                    })

                # æ£€æŸ¥é•¿è¡Œ
                if len(line) > 120:
                    issues.append({
                        "type": "complexity",
                        "severity": "info",
                        "line": i,
                        "message": f"Line too long ({len(line)} characters)",
                        "suggestion": "Break the line into multiple lines"
                    })

            return issues

    ```python

    def check_security(self, code: str, language: str) -> List[Dict]:
        """æ£€æŸ¥å®‰å…¨é—®é¢˜"""
        issues = []

```python
        if language == "python":
            # æ£€æŸ¥ eval ä½¿ç”¨
            eval_pattern = r'\beval\s*\('
            for match in re.finditer(eval_pattern, code):
                line_num = code[:match.start()].count('\n') + 1
                issues.append({
                    "type": "security",
                    "severity": "error",
                    "line": line_num,
                    "message": "Use of eval() is dangerous",
                    "suggestion": "Use ast.literal_eval() or alternative safe methods"
                })

            # æ£€æŸ¥ exec ä½¿ç”¨
            exec_pattern = r'\bexec\s*\('
            for match in re.finditer(exec_pattern, code):
                line_num = code[:match.start()].count('\n') + 1
                issues.append({
                    "type": "security",
                    "severity": "error",
                    "line": line_num,
                    "message": "Use of exec() is dangerous",
                    "suggestion": "Avoid using exec() for security reasons"
                })

            # æ£€æŸ¥ç¡¬ç¼–ç å¯†ç 
            password_pattern = r'(password|passwd|pwd)\s*=\s*["\'][^"\']+["\']'
            for match in re.finditer(password_pattern, code, re.IGNORECASE):
                line_num = code[:match.start()].count('\n') + 1
                issues.append({
                    "type": "security",
                    "severity": "warning",
                    "line": line_num,
                    "message": "Hardcoded password detected",
                    "suggestion": "Use environment variables or configuration files"
                })

        elif language == "javascript":
            # æ£€æŸ¥ innerHTML ä½¿ç”¨
            innerhtml_pattern = r'\.innerHTML\s*='
            for match in re.finditer(innerhtml_pattern, code):
                line_num = code[:match.start()].count('\n') + 1
                issues.append({
                    "type": "security",
                    "severity": "warning",
                    "line": line_num,
                    "message": "Use of innerHTML can lead to XSS vulnerabilities",
                    "suggestion": "Use textContent or sanitize input"
                })

        return issues

    def check_performance(self, code: str, language: str) -> List[Dict]:
        """æ£€æŸ¥æ€§èƒ½é—®é¢˜"""
        issues = []

        if language == "python":
            # æ£€æŸ¥å¾ªç¯ä¸­çš„å­—ç¬¦ä¸²æ‹¼æ¥
            lines = code.split('\n')
            in_loop = False
            loop_indent = 0

            for i, line in enumerate(lines, 1):
                # æ£€æµ‹å¾ªç¯
                if re.match(r'\s*(for|while)\s+', line):
                    in_loop = True
                    loop_indent = len(line) - len(line.lstrip())
                elif in_loop and len(line) - len(line.lstrip()) <= loop_indent:
                    in_loop = False

                # æ£€æŸ¥å­—ç¬¦ä¸²æ‹¼æ¥
                if in_loop and '+=' in line and '"' in line and "'" in line:
                    issues.append({
                        "type": "performance",
                        "severity": "warning",
                        "line": i,
                        "message": "String concatenation in loop may be inefficient",
                        "suggestion": "Use list and join() for better performance"
                    })

        return issues

    def check_documentation(self, code: str, language: str) -> List[Dict]:
        """æ£€æŸ¥æ–‡æ¡£"""
        issues = []

        if language == "python":
            # æ£€æŸ¥å‡½æ•°æ˜¯å¦æœ‰æ–‡æ¡£å­—ç¬¦ä¸²
            func_pattern = r'def\s+(\w+)\s*\([^)]*\):'
            for match in re.finditer(func_pattern, code):
                func_name = match.group(1)
                func_start = match.end()

# æ£€æŸ¥ä¸‹ä¸€è¡Œæ˜¯å¦æœ‰æ–‡æ¡£å­—ç¬¦ä¸²

remaining_code = code[func_start:func_start + 100] if not re.search(r'\s*"""', remaining_code): line_num = code[:match.start()].count('\n') + 1 issues.append({ "type": "documentation", "severity": "info", "line": line_num, "message": f"Function '{func_name}' lacks docstring", "suggestion": "Add a docstring to describe the function" })

```

```
return issues

def generate_report(self, code: str, issues: List[Dict], file_path: str) -> str: """ç”Ÿæˆå®¡æŸ¥æŠ¥å‘Š""" report = f"# Code Review Report for {file_path}\n\n"

# ç»Ÿè®¡

error_count = sum(1 for i in issues if i["severity"] == "error") warning_count = sum(1 for i in issues if i["severity"] == "warning") info_count = sum(1 for i in issues if i["severity"] == "info")

report += f"## Summary\n\n" report += f"- Total Issues: {len(issues)}\n" report += f"- Errors: {error_count}\n" report += f"- Warnings: {warning_count}\n" report += f"- Info: {info_count}\n\n"

# æŒ‰ç±»å‹åˆ†ç»„

issues_by_type = {} for issue in issues: issue_type = issue["type"] if issue_type not in issues_by_type: issues_by_type[issue_type] = [] issues_by_type[issue_type].append(issue)

# è¯¦ç»†é—®é¢˜

for issue_type, type_issues in issues_by_type.items(): report += f"## {issue_type.title()} Issues ({len(type_issues)})\n\n"

for issue in type_issues: severity_icon = { "error": "âŒ", "warning": "âš ï¸", "info": "â„¹ï¸" }.get(issue["severity"], "â€¢")

report += f"{severity_icon} **Line {issue['line']}** : {issue['message']}\n" if "suggestion" in issue: report += f" ğŸ’¡ Suggestion: {issue['suggestion']}\n" report += "\n"

return report

### 2\. ä»£ç é£æ ¼æ£€æŸ¥

#### 2.1 PEP 8 æ£€æŸ¥

    bash


    python

    # src/skills/pep8_checker.py
    from typing import Dict, Any, List
    from claude_code_sdk import Skill, SkillContext, SkillResult
    import re

    class PEP8CheckerSkill(Skill):
        """PEP 8 ä»£ç é£æ ¼æ£€æŸ¥æŠ€èƒ½"""

        def __init__(self):
            super().__init__(
                name="pep8-checker",
                version="1.0.0",
                description="PEP 8 style checker"
            )

        def get_parameters_schema(self) -> Dict[str, Any]:
            return {
                "type": "object",
                "properties": {
                    "file_path": {
                        "type": "string",
                        "description": "Path to the file to check"
                    },
                    "code": {
                        "type": "string",
                        "description": "Code to check"
                    },
                    "max_line_length": {
                        "type": "integer",
                        "description": "Maximum line length",
                        "default": 79
                    }
                }
            }

        def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
            try:
                max_line_length = parameters.get("max_line_length", 79)

                # è·å–ä»£ç 
                if "file_path" in parameters:
                    code = context.read_file(parameters["file_path"])
                    file_path = parameters["file_path"]
                elif "code" in parameters:
                    code = parameters["code"]
                    file_path = "<inline>"
                else:
                    return SkillResult(
                        success=False,
                        error="Either file_path or code must be provided"
                    )

                # æ‰§è¡Œæ£€æŸ¥
                violations = self.check_pep8(code, max_line_length)

                return SkillResult(
                    success=True,
                    data={
                        "file_path": file_path,
                        "max_line_length": max_line_length,
                        "violations": violations,
                        "violation_count": len(violations)
                    }
                )
            except Exception as e:
                return SkillResult(
                    success=False,
                    error=str(e)
                )

        def check_pep8(self, code: str, max_line_length: int) -> List[Dict]:
            """æ£€æŸ¥ PEP 8 è§„èŒƒ"""
            violations = []
            lines = code.split('\n')

            for i, line in enumerate(lines, 1):
                # æ£€æŸ¥è¡Œé•¿åº¦
                if len(line) > max_line_length:
                    violations.append({
                        "line": i,
                        "code": "E501",
                        "message": f"Line too long ({len(line)} > {max_line_length} characters)",
                        "severity": "warning"
                    })

                # æ£€æŸ¥å°¾éšç©ºæ ¼
                if line.rstrip() != line.rstrip('\n').rstrip('\r'):
                    violations.append({
                        "line": i,
                        "code": "W291",
                        "message": "Trailing whitespace",
                        "severity": "warning"
                    })

                # æ£€æŸ¥ç©ºè¡Œ
                if line.strip() == "" and i < len(lines):
                    # æ£€æŸ¥è¿ç»­ç©ºè¡Œ
                    if i > 1 and lines[i-2].strip() == "" and lines[i-1].strip() == "":
                        violations.append({
                            "line": i,
                            "code": "E303",
                            "message": "Too many blank lines",
                            "severity": "info"
                        })

                # æ£€æŸ¥å¯¼å…¥é¡ºåº
                if line.strip().startswith("import ") or line.strip().startswith("from "):
                    if i > 1 and lines[i-2].strip() and not (
                        lines[i-2].strip().startswith("import ") or
                        lines[i-2].strip().startswith("from ")
                    ):
                        violations.append({
                            "line": i,
                            "code": "E402",
                            "message": "Module level import not at top of file",
                            "severity": "error"
                        })

            return violations

    ### 3. ä»£ç é‡å¤æ£€æµ‹

    #### 3.1 é‡å¤ä»£ç æ£€æŸ¥

    ```python

    # src/skills/duplicate_detector.py

```python
    from typing import Dict, Any, List, Tuple
    from claude_code_sdk import Skill, SkillContext, SkillResult
    import difflib

    class DuplicateDetectorSkill(Skill):
        """é‡å¤ä»£ç æ£€æµ‹æŠ€èƒ½"""

        def __init__(self):
            super().__init__(
                name="duplicate-detector",
                version="1.0.0",
                description="Detect duplicate code blocks"
            )

        def get_parameters_schema(self) -> Dict[str, Any]:
            return {
                "type": "object",
                "properties": {
                    "file_path": {
                        "type": "string",
                        "description": "Path to the file to check"
                    },
                    "code": {
                        "type": "string",
                        "description": "Code to check"
                    },
                    "min_lines": {
                        "type": "integer",
                        "description": "Minimum number of lines to consider as duplicate",
                        "default": 5
                    },
                    "similarity_threshold": {
                        "type": "number",
                        "description": "Similarity threshold (0.0 to 1.0)",
                        "default": 0.8
                    }
                }
            }

        def execute(self, parameters: Dict[str, Any], context: SkillContext) -> SkillResult:
    try:
    min_lines = parameters.get("min_lines", 5)
    similarity_threshold = parameters.get("similarity_threshold", 0.8)

                # è·å–ä»£ç 
    if "file_path" in parameters:
    code = context.read_file(parameters["file_path"])
    file_path = parameters["file_path"]
    elif "code" in parameters:
    code = parameters["code"]
    file_path = "<inline>"
    else:
    return SkillResult(
    success=False,
    error="Either file_path or code must be provided"
            )

                # æ£€æµ‹é‡å¤
    duplicates = self.detect_duplicates(code, min_lines, similarity_threshold)
    return SkillResult(
    success=True,
    data={
    "file_path": file_path,
    "min_lines": min_lines,
    "similarity_threshold": similarity_threshold,
    "duplicates": duplicates,
    "duplicate_count": len(duplicates)
            }
        )
    except Exception as e:
    return SkillResult(
    success=False,
    error=str(e)
        )

        def detect_duplicates(self, code: str, min_lines: int,
                         similarity_threshold: float) -> List[Dict]:
            """æ£€æµ‹é‡å¤ä»£ç å—"""
            lines = code.split('\n')
            duplicates = []

            # æå–ä»£ç å—
    blocks = self.extract_blocks(lines, min_lines)
    # æ¯”è¾ƒæ‰€æœ‰å—å¯¹
    for i, block1 in enumerate(blocks):
    for j, block2 in enumerate(blocks):
    if i >= j:
    continue
    similarity = self.calculate_similarity(block1["code"], block2["code"])
    if similarity >= similarity_threshold:
                duplicates.append({
    "block1": {
    "start_line": block1["start_line"],
    "end_line": block1["end_line"],
    "code": block1["code"]
    },
    "block2": {
    "start_line": block2["start_line"],
    "end_line": block2["end_line"],
    "code": block2["code"]
    },
    "similarity": similarity,
    "suggestion": "Consider extracting common code into a function"
            })

            return duplicates

        def extract_blocks(self, lines: List[str], min_lines: int) -> List[Dict]:
    """æå–ä»£ç å—"""
    blocks = []
    for i in range(len(lines) - min_lines + 1):
    block_code = '\n'.join(lines[i:i+min_lines])
    blocks.append({
    "start_line": i + 1,
    "end_line": i + min_lines,
    "code": block_code
    })
    return blocks
    def calculate_similarity(self, code1: str, code2: str) -> float:
    """è®¡ç®—ä»£ç ç›¸ä¼¼åº¦"""
    # ä½¿ç”¨åºåˆ—åŒ¹é…å™¨
    matcher = difflib.SequenceMatcher(None, code1, code2)
    return matcher.ratio()

## ä½¿ç”¨ç¤ºä¾‹

### 1\. å®Œæ•´ä»£ç å®¡æŸ¥

    bash


    python

    # examples/code_review.py
    from skills.code_reviewer import CodeReviewerSkill
    from claude_code_sdk import SkillContext

    skill = CodeReviewerSkill()
    context = SkillContext()

    result = skill.execute(
        {
            "file_path": "src/main.py",
            "language": "python",
            "rules": ["naming", "complexity", "security", "performance", "documentation"],
            "severity": "all"
        },
        context
    )

    print(f"Found {result.data['issue_count']} issues")
    print(result.data["report"])

### 2\. PEP 8 æ£€æŸ¥

    python


    # examples/pep8_check.py
    from skills.pep8_checker import PEP8CheckerSkill
    from claude_code_sdk import SkillContext

    skill = PEP8CheckerSkill()
    context = SkillContext()

    result = skill.execute(
        {
    "file_path": "src/main.py",
    "max_line_length": 79
    },
    context
    )
    print(f"Found {result.data['violation_count']} PEP 8 violations")
    for violation in result.data["violations"]:
    print(f"Line {violation['line']}: {violation['message']}")

### 3\. é‡å¤ä»£ç æ£€æµ‹

    bash


    python

    # examples/duplicate_detection.py
    from skills.duplicate_detector import DuplicateDetectorSkill
    from claude_code_sdk import SkillContext

    skill = DuplicateDetectorSkill()
    context = SkillContext()

    result = skill.execute(
        {
            "file_path": "src/main.py",
            "min_lines": 5,
            "similarity_threshold": 0.8
        },
        context
    )

    print(f"Found {result.data['duplicate_count']} duplicate blocks")
    for duplicate in result.data["duplicates"]:
        print(f"Lines {duplicate['block1']['start_line']}-{duplicate['block1']['end_line']} "
              f"similar to lines {duplicate['block2']['start_line']}-{duplicate['block2']['end_line']} "
              f"(similarity: {duplicate['similarity']:.2f})")

    ## æœ€ä½³å®è·µ

    ### 1. å®¡æŸ¥è§„åˆ™é…ç½®

    #### 1. è§„åˆ™ä¼˜å…ˆçº§
    - å®‰å…¨è§„åˆ™ï¼šæœ€é«˜ä¼˜å…ˆçº§
    - æ€§èƒ½è§„åˆ™ï¼šé«˜ä¼˜å…ˆçº§
    - ä»£ç è´¨é‡ï¼šä¸­ä¼˜å…ˆçº§
    - ä»£ç é£æ ¼ï¼šä½ä¼˜å…ˆçº§
    ### 2. è§„åˆ™å®šåˆ¶
    - æ ¹æ®é¡¹ç›®éœ€æ±‚å®šåˆ¶è§„åˆ™
    - è€ƒè™‘å›¢é˜Ÿç¼–ç è§„èŒƒ
    - é€æ­¥å¼•å…¥æ–°è§„åˆ™
    ### 3. è§„åˆ™ä¾‹å¤–
    - æä¾›è§„åˆ™ä¾‹å¤–æœºåˆ¶
    - è®°å½•ä¾‹å¤–åŸå› 
    - å®šæœŸå®¡æŸ¥ä¾‹å¤–

### 2\. å®¡æŸ¥æµç¨‹

    bash


    markdown

    #### 1. è‡ªåŠ¨å®¡æŸ¥
    - åœ¨æäº¤å‰è‡ªåŠ¨è¿è¡Œ
    - é›†æˆåˆ° CI/CD æµç¨‹
    - é˜»æ­¢ä¸ç¬¦åˆè§„èŒƒçš„ä»£ç 

    ### 2. äººå·¥å®¡æŸ¥
    - å®¡æŸ¥è‡ªåŠ¨å®¡æŸ¥ç»“æœ
    - å…³æ³¨å¤æ‚é€»è¾‘
    - æä¾›å»ºè®¾æ€§åé¦ˆ

    ### 3. æŒç»­æ”¹è¿›
    - æ”¶é›†å®¡æŸ¥åé¦ˆ
    - ä¼˜åŒ–å®¡æŸ¥è§„åˆ™
    - æé«˜å®¡æŸ¥æ•ˆç‡

## æ€»ç»“

```

ä»£ç å®¡æŸ¥æŠ€èƒ½å¯ä»¥å¸®åŠ©å›¢é˜Ÿè‡ªåŠ¨åŒ–ä»£ç å®¡æŸ¥æµç¨‹ï¼Œæé«˜ä»£ç è´¨é‡å’Œä¸€è‡´æ€§ã€‚é€šè¿‡åˆç†é…ç½®å®¡æŸ¥è§„åˆ™å’Œæµç¨‹ï¼Œå¯ä»¥æ˜¾è‘—å‡å°‘ä»£ç ä¸­çš„é—®é¢˜ï¼Œæé«˜å¼€å‘æ•ˆç‡ã€‚

åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨æ–‡æ¡£ç”ŸæˆæŠ€èƒ½ã€‚
