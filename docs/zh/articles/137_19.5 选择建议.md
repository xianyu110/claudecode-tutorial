# 19.5 选择建议

## 19.5.1 决策框架

### 1\. 评估维度


在选择使用 Skills 还是插件时，需要从多个维度进行评估：

```python
    python


    class DecisionFramework:
        def __init__(self):
            self.weights = {
                "development_speed": 0.25,    # 开发速度
                "performance": 0.20,          # 性能
                "maintainability": 0.15,      # 可维护性
                "flexibility": 0.15,          # 灵活性
                "security": 0.10,             # 安全性
                "scalability": 0.10,          # 可扩展性
                "learning_curve": 0.05        # 学习曲线
            }

        def evaluate(self, requirements):
            """评估方案"""
            scores = {
                "skills": self._evaluate_skills(requirements),
                "plugin": self._evaluate_plugin(requirements)
            }

            # 计算加权分数
            weighted_scores = {}
            for option, score in scores.items():
                weighted_score = sum(
                    score[dim] * self.weights[dim]
                    for dim in score
                )
                weighted_scores[option] = weighted_score

            return weighted_scores

        def _evaluate_skills(self, requirements):
            """评估 Skills"""
            return {
                "development_speed": 0.9,    # 开发速度快
                "performance": 0.4,          # 性能一般
                "maintainability": 0.6,      # 可维护性中等
                "flexibility": 0.9,          # 灵活性高
                "security": 0.5,             # 安全性中等
                "scalability": 0.5,          # 可扩展性中等
                "learning_curve": 0.8        # 学习曲线平缓
            }

        def _evaluate_plugin(self, requirements):
            """评估插件"""
            return {
                "development_speed": 0.5,    # 开发速度中等
                "performance": 0.9,          # 性能高
                "maintainability": 0.8,      # 可维护性高
                "flexibility": 0.6,          # 灵活性中等
                "security": 0.9,             # 安全性高
                "scalability": 0.9,          # 可扩展性高
                "learning_curve": 0.4        # 学习曲线陡峭
            }

### 2\. 决策树

    python


    class DecisionTree:
        def __init__(self):
            self.tree = self._build_tree()

        def _build_tree(self):
            """构建决策树"""
            return {
                "question": "是否需要快速原型开发？",
                "yes": {
                    "question": "是否依赖自然语言理解？",
                    "yes": "Skills",
                    "no": {
                        "question": "性能是否是关键因素？",
                        "yes": "插件",
                        "no": "Skills"
                    }
                },
                "no": {
                    "question": "是否需要高性能执行？",
                    "yes": {
                        "question": "是否需要严格的安全控制？",
                        "yes": "插件",
                        "no": {
                            "question": "是否需要与系统深度集成？",
                            "yes": "插件",
                            "no": "Skills"
                        }
                    },
                    "no": {
                        "question": "是否需要封装特定知识？",
                        "yes": "Skills",
                        "no": {
                            "question": "是否需要确定性执行？",
                            "yes": "插件",
                            "no": "Skills"
                        }
                    }
                }
            }

        def decide(self, requirements):
            """决策"""
            node = self.tree
            while isinstance(node, dict):
                question = node["question"]
                answer = self._answer_question(question, requirements)
                node = node[answer]
            return node

        def _answer_question(self, question, requirements):
            """回答问题"""
            # 简化实现，实际应该根据 requirements 判断
            if "快速原型" in question:
                return "yes" if requirements.get("rapid_prototyping") else "no"
            elif "自然语言" in question:
                return "yes" if requirements.get("nlp_required") else "no"
            elif "性能" in question:
                return "yes" if requirements.get("high_performance") else "no"
            elif "安全" in question:
                return "yes" if requirements.get("high_security") else "no"
            elif "集成" in question:
                return "yes" if requirements.get("deep_integration") else "no"
            elif "知识" in question:
                return "yes" if requirements.get("knowledge_encapsulation") else "no"
            elif "确定性" in question:
                return "yes" if requirements.get("deterministic") else "no"
            return "no"

    ## 19.5.2 场景化建议

    #### 场景 1：快速原型开发

    > **特征**：
    - 需求不明确，经常变化
    - 需要快速验证想法
    - 开发时间有限

    > **示例**：
    用户：我需要创建一个技能，用于分析用户反馈，提取关键问题和建议
    Claude Code：我会创建一个用户反馈分析技能。
    技能配置：
    - 名称：feedback-analyzer
    - 描述：分析用户反馈，提取关键问题和建议
    - 输入：用户反馈文本
    - 输出：关键问题列表、建议列表、情感分析
    使用示例：
    请分析以下用户反馈：
    "产品很好用，但是加载速度有点慢。希望增加导出功能。"

```

**优势** ：

  * 无需编写代码
  * 快速迭代
  * 易于调整

#### 场景 2：知识密集型任务

**特征** ：

  * 需要应用特定领域知识
  * 需要理解和推理
  * 需要灵活的输出格式 **示例** ：

```python
    python


    # 技能：法律文档分析
    class LegalDocumentSkill(Skill):
        def execute(self, parameters, context):
            document = parameters["document"]
            analysis_type = parameters["analysis_type"]

            if analysis_type == "risk_assessment":
                return self.assess_risks(document)
            elif analysis_type == "clause_extraction":
                return self.extract_clauses(document)
            elif analysis_type == "compliance_check":
                return self.check_compliance(document)

    **优势**：
    - 强大的理解能力
    - 灵活的知识应用
    - 适应性强

    #### 场景 3：教育和培训

    > **特征**：
    - 需要解释和说明
    - 需要个性化反馈
    - 需要适应不同水平

    > **示例**：
    技能：编程导师
    功能：
    - 解释编程概念
    - 提供代码示例
    - 生成练习题
    - 评估代码质量
    使用场景：
    - 新手学习编程
    - 代码审查指导
    - 最佳实践教学


**优势** ：

  * 个性化教学
  * 即时反馈
  * 自适应难度

### 2\. 推荐使用插件的场景

#### 场景 1：高性能计算

```

**特征** ：

  * 需要处理大量数据
  * 需要实时响应
  * 性能是关键因素 **示例** ：

```python
    python


    # 插件：高性能数据处理
    class HighPerformancePlugin(Plugin):
        def __init__(self):
            super().__init__()
            self.thread_pool = ThreadPoolExecutor(max_workers=8)
            self.process_pool = ProcessPoolExecutor(max_workers=4)

        def process_large_dataset(self, data_path):
            """处理大数据集"""
            # 使用多进程处理
            chunks = self.split_dataset(data_path, chunk_size=10000)

            futures = [
                self.process_pool.submit(self.process_chunk, chunk)
                for chunk in chunks
            ]

            results = [future.result() for future in futures]
            return self.merge_results(results)

    **优势**：
    - 高性能执行
    - 并行处理
    - 资源优化

    #### 场景 2：系统集成

    > **特征**：
    - 需要与操作系统交互
    - 需要访问系统资源
    - 需要精确控制

    > **示例**：
    # 插件：文件系统集成
    class FileSystemPlugin(Plugin):
    def __init__(self):
    super().__init__()
    self.permission_checker = PermissionChecker()
    def copy_file(self, source, destination, user):
    """复制文件"""
    # 检查权限
    if not self.permission_checker.check_read_permission(user, source):
    raise PermissionError("无读取权限")
    if not self.permission_checker.check_write_permission(user, destination):
    raise PermissionError("无写入权限")
    # 执行复制
    import shutil
    shutil.copy2(source, destination)
    # 记录审计日志
    self.audit_logger.log("copy_file", user, {
    "source": source,
    "destination": destination
    })
    return {"success": True}

```

**优势** ：

  * 直接系统访问
  * 精确权限控制
  * 完整的审计日志

#### 场景 3：安全敏感操作

**特征** ：

  * 涉及敏感数据
  * 需要严格的安全控制
  * 需要合规性 **示例** ：

```python
    python


    # 插件：加密服务
    class EncryptionPlugin(Plugin):
        def __init__(self, key_store):
            super().__init__()
            self.key_store = key_store
            self.audit_logger = AuditLogger()

        def encrypt_data(self, data, user, key_id):
            """加密数据"""
            # 检查权限
            if not self.check_encryption_permission(user, key_id):
                raise PermissionError("无加密权限")

            # 获取密钥
            key = self.key_store.get_key(key_id)

            # 加密数据
            from cryptography.fernet import Fernet
            f = Fernet(key)
            encrypted = f.encrypt(data.encode())

            # 记录审计日志
            self.audit_logger.log("encrypt_data", user, {
                "key_id": key_id,
                "data_size": len(data)
            })

            return encrypted

        def decrypt_data(self, encrypted_data, user, key_id):
            """解密数据"""
            # 检查权限
            if not self.check_decryption_permission(user, key_id):
                raise PermissionError("无解密权限")

            # 获取密钥
            key = self.key_store.get_key(key_id)

            # 解密数据
            from cryptography.fernet import Fernet
            f = Fernet(key)
            decrypted = f.decrypt(encrypted_data).decode()

            # 记录审计日志
            self.audit_logger.log("decrypt_data", user, {
                "key_id": key_id,
                "data_size": len(decrypted)
            })

            return decrypted

    **优势**：
    - 严格的安全控制
    - 完整的审计追踪
    - 合规性支持

    ### 3. 混合使用的场景

    #### 场景 1：代码审查流程

    # 插件：Git 集成
    class GitPlugin(Plugin):
    def get_changed_files(self, branch):
    """获取变更的文件"""
    import subprocess
    result = subprocess.run(
    ['git', 'diff', '--name-only', branch],
    capture_output=True,
    text=True
    )
    return result.stdout.splitlines()
    def get_file_content(self, file_path):
    """获取文件内容"""
    with open(file_path, 'r') as f:
    return f.read()
    # 技能：代码审查
    class CodeReviewSkill(Skill):
    def execute(self, parameters, context):
    # 使用插件获取变更的文件
    git_plugin = context.get_plugin("git")
    changed_files = git_plugin.get_changed_files(parameters["branch"])
    # 对每个文件进行审查
    reviews = []
    for file_path in changed_files:
    content = git_plugin.get_file_content(file_path)
    review = self.review_code(content, file_path)
    reviews.append(review)
    return SkillResult(success=True, data={"reviews": reviews})

#### 场景 2：数据分析流程

    python


    # 插件：数据库访问
    class DatabasePlugin(Plugin):
        def query_data(self, query, params=None):
            """查询数据"""
            import sqlite3
            conn = sqlite3.connect('database.db')
            cursor = conn.cursor()
            cursor.execute(query, params or ())
            results = cursor.fetchall()
            conn.close()
            return results

    # 技能：数据分析
    class DataAnalysisSkill(Skill):
        def execute(self, parameters, context):
            # 使用插件获取数据
            db_plugin = context.get_plugin("database")
            data = db_plugin.query_data(parameters["query"])

            # 使用 Claude 分析数据
            analysis = self.analyze_data(data, parameters["analysis_type"])

            return SkillResult(success=True, data={"analysis": analysis})

    ## 19.5.3 迁移策略

    ### 1. 从 Skills 迁移到插件

    > **迁移场景**：
    - Skills 性能不足
    - 需要更严格的安全控制
    - 需要更好的可维护性

    > **迁移步骤**：
    # 1. 分析 Skills 的行为
    class SkillAnalyzer:
    def analyze(self, skill):
    """分析技能"""
    analysis = {
    "inputs": self.extract_input_patterns(skill),
    "outputs": self.extract_output_patterns(skill),
    "logic": self.extract_logic_patterns(skill),
    "dependencies": self.extract_dependencies(skill)
    }
    return analysis
    # 2. 设计插件接口
    class PluginDesigner:
    def design(self, skill_analysis):
    """设计插件"""
    design = {
    "methods": self.design_methods(skill_analysis),
    "data_structures": self.design_data_structures(skill_analysis),
    "apis": self.design_apis(skill_analysis)
    }
    return design
    # 3. 实现插件
    class PluginMigrator:
    def migrate(self, skill, plugin_design):
    """迁移到插件"""
    # 创建插件类
    plugin_class = self.create_plugin_class(plugin_design)
    # 实现方法
    for method_design in plugin_design["methods"]:
    self.implement_method(plugin_class, method_design)
    # 测试插件
    self.test_plugin(plugin_class, skill)
    return plugin_class

### 2\. 从插件迁移到 Skills

```

**迁移场景** ：

  * 需要更灵活的交互
  * 需要自然语言理解
  * 需要快速迭代 **迁移步骤** ：

```python
    python


    # 1. 分析插件的功能
    class PluginAnalyzer:
        def analyze(self, plugin):
            """分析插件"""
            analysis = {
                "methods": self.extract_methods(plugin),
                "parameters": self.extract_parameters(plugin),
                "logic": self.extract_logic(plugin),
                "use_cases": self.extract_use_cases(plugin)
            }
            return analysis

    # 2. 设计 Skills
    class SkillDesigner:
        def design(self, plugin_analysis):
            """设计技能"""
            design = {
                "name": self.generate_name(plugin_analysis),
                "description": self.generate_description(plugin_analysis),
                "examples": self.generate_examples(plugin_analysis),
                "prompts": self.generate_prompts(plugin_analysis)
            }
            return design

    # 3. 创建 Skills
    class SkillCreator:
        def create(self, skill_design):
            """创建技能"""
            skill = Skill(
                name=skill_design["name"],
                description=skill_design["description"]
            )

            # 添加示例
            for example in skill_design["examples"]:
                skill.add_example(example)

            # 配置提示
            skill.set_prompts(skill_design["prompts"])

            # 测试技能
            self.test_skill(skill)

            return skill

    ## 19.5.4 最佳实践

    ### 1. Skills 最佳实践

    class SkillBestPractices:
    """Skills 最佳实践"""
    # 1. 清晰的描述
    def create_skill_with_clear_description(self):
    return Skill(
    name="code-reviewer",
    description="""
    代码审查技能，用于分析代码质量、识别潜在问题、提供改进建议。
    功能：
    - 代码质量评估
    - 潜在问题识别
    - 最佳实践建议
    - 性能优化建议
    """
    )
    # 2. 丰富的示例
    def create_skill_with_examples(self):
    skill = Skill(name="code-reviewer")
    skill.add_example({
    "input": "def add(a, b): return a + b",
    "output": """
    代码审查结果：
    - 代码简洁清晰
    - 建议添加类型注解
    - 建议添加文档字符串
    """
    })
    return skill
    # 3. 上下文感知
    def create_context_aware_skill(self):
    skill = Skill(name="context-aware")
    def execute(parameters, context):
    # 利用上下文信息
    project_info = context.get_project_info()
    user_preferences = context.get_user_preferences()
    # 根据上下文调整行为
    if user_preferences.get("strict_mode"):
    return self.strict_review(parameters["code"])
    else:
    return self.relaxed_review(parameters["code"])
    skill.execute = execute
    return skill

### 2\. 插件最佳实践

    python


    class PluginBestPractices:
        """插件最佳实践"""

        # 1. 类型安全
        def create_type_safe_plugin(self):
            from pydantic import BaseModel, validator

            class PluginInput(BaseModel):
                """插件输入"""
                value: int
                name: str

                @validator('value')
                def value_positive(cls, v):
                    if v <= 0:
                        raise ValueError('值必须大于零')
                    return v

            class TypeSafePlugin(Plugin):
                def process(self, input_data: PluginInput):
                    """处理输入"""
                    return {"result": input_data.value * 2}

            return TypeSafePlugin()

        # 2. 错误处理
        def create_robust_plugin(self):
            class RobustPlugin(Plugin):
                def process(self, parameters):
                    """处理参数"""
                    try:
                        # 验证参数
                        self.validate_parameters(parameters)

                        # 执行逻辑
                        result = self.execute_logic(parameters)

                        return {"success": True, "data": result}

                    except ValidationError as e:
                        return {"success": False, "error": f"参数验证失败: {e}"}

                    except Exception as e:
                        # 记录错误
                        self.logger.error(f"处理失败: {e}")
                        return {"success": False, "error": "处理失败"}

            return RobustPlugin()

        # 3. 资源管理
        def create_resource_managed_plugin(self):
            class ResourceManagedPlugin(Plugin):
                def __init__(self):
                    super().__init__()
                    self.connection_pool = None
                    self.cache = None

                def initialize(self, config):
                    """初始化资源"""
                    # 创建连接池
                    self.connection_pool = ConnectionPool(
                        max_size=config.get("pool_size", 10)
                    )

                    # 创建缓存
                    self.cache = LRUCache(maxsize=1000)

                def process(self, parameters):
                    """处理参数"""
                    # 使用连接池
                    with self.connection_pool.get_connection() as conn:
                        # 检查缓存
                        cache_key = self.get_cache_key(parameters)
                        cached_result = self.cache.get(cache_key)

                        if cached_result:
                            return cached_result

                        # 执行逻辑
                        result = self.execute_logic(parameters, conn)

                        # 缓存结果
                        self.cache.set(cache_key, result)

                        return result

                def cleanup(self):
                    """清理资源"""
                    if self.connection_pool:
                        self.connection_pool.close()
                    if self.cache:
                        self.cache.clear()

            return ResourceManagedPlugin()

## 19.5.5 总结

### 选择指南

```

场景| 推荐| 理由
---|---|---

快速原型开发| Skills| 开发速度快，易于迭代
自然语言处理| Skills| 强大的语言理解能力
知识封装| Skills| 灵活的知识应用
教育培训| Skills| 个性化交互
高性能计算| 插件| 高效的执行性能
系统集成| 插件| 直接的系统访问
安全敏感操作| 插件| 严格的安全控制
复杂业务逻辑| 插件| 确定性和可维护性
混合需求| 混合使用| 结合两者优势

### 决策流程

  1. **评估需求** ：明确功能需求、性能要求、安全要求
  2. **分析约束** ：考虑开发时间、资源限制、团队能力
  3. **选择方案** ：根据决策框架选择合适的方案
  4. **实施验证** ：实现原型并进行验证
  5. **迭代优化** ：根据反馈持续优化

### 关键原则

  1. **从简单开始** ：优先选择 Skills 进行快速验证
  2. **按需优化** ：当性能或安全成为瓶颈时，考虑迁移到插件
  3. **灵活组合** ：不要局限于单一方案，灵活组合使用
  4. **持续评估** ：定期评估现有方案，根据需求变化调整
