# 22.1 复杂插件设计

```python
## 22.1.1 插件架构模式

### 1\. 分层架构

// src/plugin.ts import { Plugin, PluginConfig, PluginContext } from '@claude-code/plugin-sdk';

```

/**

```python
  * 分层架构插件 */ export class LayeredPlugin extends Plugin { private presentationLayer: PresentationLayer; private businessLayer: BusinessLayer; private dataLayer: DataLayer;

constructor() { super({ name: 'layered-plugin', version: '1.0.0', description: 'A plugin with layered architecture' });

// 初始化各层 this.dataLayer = new DataLayer(); this.businessLayer = new BusinessLayer(this.dataLayer); this.presentationLayer = new PresentationLayer(this.businessLayer); }

async initialize(config: PluginConfig): Promise<void> { // 初始化数据层 await this.dataLayer.initialize(config.data);

// 初始化业务层 await this.businessLayer.initialize(config.business);

// 初始化表示层 await this.presentationLayer.initialize(config.presentation); }

async start(): Promise<void> { // 启动数据层 await this.dataLayer.start();

// 启动业务层 await this.businessLayer.start();

// 启动表示层 await this.presentationLayer.start(); }

async stop(): Promise<void> { // 停止表示层 await this.presentationLayer.stop();

// 停止业务层 await this.businessLayer.stop();

// 停止数据层 await this.dataLayer.stop(); }

async cleanup(): Promise<void> { // 清理表示层 await this.presentationLayer.cleanup();

// 清理业务层 await this.businessLayer.cleanup();

// 清理数据层 await this.dataLayer.cleanup(); } }

```

/**

```python
  * 表示层 */ class PresentationLayer { constructor(private businessLayer: BusinessLayer) {}

async initialize(config: any): Promise<void> { // 初始化表示层 }

async start(): Promise<void> { // 启动表示层 }

async stop(): Promise<void> { // 停止表示层 }

async cleanup(): Promise<void> { // 清理表示层 }

```

/**

```
  * 处理用户请求 */ async handleRequest(request: any): Promise<any> { // 转发到业务层 return this.businessLayer.processRequest(request); } }

```

/**

```python
  * 业务层 */ class BusinessLayer { constructor(private dataLayer: DataLayer) {}

async initialize(config: any): Promise<void> { // 初始化业务层 }

async start(): Promise<void> { // 启动业务层 }

async stop(): Promise<void> { // 停止业务层 }

async cleanup(): Promise<void> { // 清理业务层 }

```

/**

```javascript
  * 处理业务逻辑 */ async processRequest(request: any): Promise<any> { // 业务逻辑处理 const data = await this.dataLayer.fetchData(request); return this.transformData(data); }

private transformData(data: any): any { // 数据转换 return data; } }

```

/**

```python
  * 数据层 */ class DataLayer { async initialize(config: any): Promise<void> { // 初始化数据层 }

async start(): Promise<void> { // 启动数据层 }

async stop(): Promise<void> { // 停止数据层 }

async cleanup(): Promise<void> { // 清理数据层 }

```

/**

```python
  * 获取数据 */ async fetchData(request: any): Promise<any> { // 数据获取逻辑 return {}; } }

### 2\. 事件驱动架构

    bash


    typescript

    // src/plugin.ts
    import { Plugin, PluginConfig } from '@claude-code/plugin-sdk';

    /**
     * 事件驱动插件
     */
    export class EventDrivenPlugin extends Plugin {
      private eventBus: EventBus;
      private eventHandlers: Map<string, EventHandler[]> = new Map();

      constructor() {
        super({
          name: 'event-driven-plugin',
          version: '1.0.0',
          description: 'An event-driven plugin'
        });

        this.eventBus = new EventBus();
      }

      async initialize(config: PluginConfig): Promise<void> {
        // 注册事件处理器
        this.registerEventHandlers();

        // 订阅事件
        this.subscribeToEvents();
      }

      async start(): Promise<void> {
        // 启动事件总线
        await this.eventBus.start();
      }

      async stop(): Promise<void> {
        // 停止事件总线
        await this.eventBus.stop();
      }

      async cleanup(): Promise<void> {
        // 清理事件处理器
        this.eventHandlers.clear();
      }

      /**
       * 注册事件处理器
       */
      private registerEventHandlers(): void {
        this.on('user.created', new UserCreatedHandler());
        this.on('user.updated', new UserUpdatedHandler());
        this.on('user.deleted', new UserDeletedHandler());
      }

      /**
       * 订阅事件
       */
      private subscribeToEvents(): void {
        this.eventBus.subscribe('user.created', async (event) => {
          await this.handleEvent('user.created', event);
        });

        this.eventBus.subscribe('user.updated', async (event) => {
          await this.handleEvent('user.updated', event);
        });

        this.eventBus.subscribe('user.deleted', async (event) => {
          await this.handleEvent('user.deleted', event);
        });
      }

      /**
       * 注册事件处理器
       */
      private on(eventType: string, handler: EventHandler): void {
        if (!this.eventHandlers.has(eventType)) {
          this.eventHandlers.set(eventType, []);
        }
        this.eventHandlers.get(eventType)!.push(handler);
      }

      /**
       * 处理事件
       */
      private async handleEvent(eventType: string, event: Event): Promise<void> {
        const handlers = this.eventHandlers.get(eventType);
        if (!handlers) {
          return;
        }

        for (const handler of handlers) {
          try {
            await handler.handle(event);
          } catch (error) {
            console.error(`Error handling event ${eventType}:`, error);
          }
        }
      }
    }

    /**
     * 事件总线
     */
    class EventBus {
      private subscribers: Map<string, EventSubscriber[]> = new Map();
      private running: boolean = false;

      async start(): Promise<void> {
        this.running = true;
      }

      async stop(): Promise<void> {
        this.running = false;
      }

      subscribe(eventType: string, subscriber: EventSubscriber): void {
        if (!this.subscribers.has(eventType)) {
          this.subscribers.set(eventType, []);
        }
        this.subscribers.get(eventType)!.push(subscriber);
      }

      unsubscribe(eventType: string, subscriber: EventSubscriber): void {
        const subscribers = this.subscribers.get(eventType);
        if (subscribers) {
          const index = subscribers.indexOf(subscriber);
          if (index > -1) {
            subscribers.splice(index, 1);
          }
        }
      }

      async publish(event: Event): Promise<void> {
        if (!this.running) {
          return;
        }

        const subscribers = this.subscribers.get(event.type);
        if (!subscribers) {
          return;
        }

        for (const subscriber of subscribers) {
          try {
            await subscriber(event);
          } catch (error) {
            console.error(`Error in subscriber for event ${event.type}:`, error);
          }
        }
      }
    }

    /**
     * 事件处理器接口
     */
    interface EventHandler {
      handle(event: Event): Promise<void>;
    }

    /**
     * 用户创建处理器
     */
    class UserCreatedHandler implements EventHandler {
      async handle(event: Event): Promise<void> {
        console.log('User created:', event.data);
        // 处理用户创建逻辑
      }
    }

    /**
     * 用户更新处理器
     */
    class UserUpdatedHandler implements EventHandler {
      async handle(event: Event): Promise<void> {
        console.log('User updated:', event.data);
        // 处理用户更新逻辑
      }
    }

    /**
     * 用户删除处理器
     */
    class UserDeletedHandler implements EventHandler {
      async handle(event: Event): Promise<void> {
        console.log('User deleted:', event.data);
        // 处理用户删除逻辑
      }
    }

    /**
     * 事件接口
     */
    interface Event {
      type: string;
      data: any;
      timestamp: Date;
    }

    /**
     * 事件订阅者
     */
    type EventSubscriber = (event: Event) => Promise<void>;

    ### 3. 微服务架构

    // src/plugin.ts
    import { Plugin, PluginConfig } from '@claude-code/plugin-sdk';
    /**
    * 微服务架构插件
    */
    export class MicroservicePlugin extends Plugin {
    private services: Map<string, Microservice> = new Map();
    private serviceRegistry: ServiceRegistry;
    private apiGateway: ApiGateway;
    constructor() {
    super({
    name: 'microservice-plugin',
    version: '1.0.0',
    description: 'A microservice architecture plugin'
    });
    this.serviceRegistry = new ServiceRegistry();
    this.apiGateway = new ApiGateway(this.serviceRegistry);
    }
    async initialize(config: PluginConfig): Promise<void> {
    // 创建微服务
    this.createServices(config.services);
    // 注册服务
    this.registerServices();
    // 配置 API 网关
    this.configureApiGateway(config.gateway);
    }
    async start(): Promise<void> {
    // 启动所有服务
    for (const service of this.services.values()) {
    await service.start();
    }
    // 启动 API 网关
    await this.apiGateway.start();
    }
    async stop(): Promise<void> {
    // 停止 API 网关
    await this.apiGateway.stop();
    // 停止所有服务
    for (const service of this.services.values()) {
    await service.stop();
    }
    }
    async cleanup(): Promise<void> {
    // 清理服务
    this.services.clear();
    }
    /**
    * 创建服务
    */
    private createServices(servicesConfig: any[]): void {
    for (const config of servicesConfig) {
    const service = this.createService(config);
    this.services.set(service.name, service);
    }
    }
    /**
    * 创建服务
    */
    private createService(config: any): Microservice {
    switch (config.type) {
    case 'user':
    return new UserService(config);
    case 'order':
    return new OrderService(config);
    case 'product':
    return new ProductService(config);
    default:
    throw new Error(`Unknown service type: ${config.type}`);
    }
    }
    /**
    * 注册服务
    */
    private registerServices(): void {
    for (const service of this.services.values()) {
    this.serviceRegistry.register(service);
    }
    }
    /**
    * 配置 API 网关
    */
    private configureApiGateway(config: any): void {
    this.apiGateway.configure(config);
    }
    }
    /**
    * 微服务基类
    */
    abstract class Microservice {
    abstract name: string;
    abstract type: string;
    protected config: any;
    protected running: boolean = false;
    constructor(config: any) {
    this.config = config;
    }
    abstract start(): Promise<void>;
    abstract stop(): Promise<void>;
    /**
    * 健康检查
    */
    async healthCheck(): Promise<boolean> {
    return this.running;
    }
    /**
    * 获取服务信息
    */
    getInfo() {
    return {
    name: this.name,
    type: this.type,
    running: this.running
    };
    }
    }
    /**
    * 用户服务
    */
    class UserService extends Microservice {
    name = 'user-service';
    type = 'user';
    async start(): Promise<void> {
    this.running = true;
    console.log('User service started');
    }
    async stop(): Promise<void> {
    this.running = false;
    console.log('User service stopped');
    }
    /**
    * 创建用户
    */
    async createUser(userData: any): Promise<any> {
    // 创建用户逻辑
    return { id: 1, ...userData };
    }
    /**
    * 获取用户
    */
    async getUser(userId: number): Promise<any> {
    // 获取用户逻辑
    return { id: userId, name: 'John Doe' };
    }
    }
    /**
    * 订单服务
    */
    class OrderService extends Microservice {
    name = 'order-service';
    type = 'order';
    async start(): Promise<void> {
    this.running = true;
    console.log('Order service started');
    }
    async stop(): Promise<void> {
    this.running = false;
    console.log('Order service stopped');
    }
    /**
    * 创建订单
    */
    async createOrder(orderData: any): Promise<any> {
    // 创建订单逻辑
    return { id: 1, ...orderData };
    }
    /**
    * 获取订单
    */
    async getOrder(orderId: number): Promise<any> {
    // 获取订单逻辑
    return { id: orderId, userId: 1, total: 100 };
    }
    }
    /**
    * 产品服务
    */
    class ProductService extends Microservice {
    name = 'product-service';
    type = 'product';
    async start(): Promise<void> {
    this.running = true;
    console.log('Product service started');
    }
    async stop(): Promise<void> {
    this.running = false;
    console.log('Product service stopped');
    }
    /**
    * 创建产品
    */
    async createProduct(productData: any): Promise<any> {
    // 创建产品逻辑
    return { id: 1, ...productData };
    }
    /**
    * 获取产品
    */
    async getProduct(productId: number): Promise<any> {
    // 获取产品逻辑
    return { id: productId, name: 'Product 1', price: 10 };
    }
    }
    /**
    * 服务注册表
    */
    class ServiceRegistry {
    private services: Map<string, Microservice> = new Map();
    register(service: Microservice): void {
    this.services.set(service.name, service);
    }
    unregister(serviceName: string): void {
    this.services.delete(serviceName);
    }
    getService(serviceName: string): Microservice | undefined {
    return this.services.get(serviceName);
    }
    getAllServices(): Microservice[] {
    return Array.from(this.services.values());
    }
    async healthCheckAll(): Promise<Map<string, boolean>> {
    const results = new Map<string, boolean>();
    for (const [name, service] of this.services.entries()) {
    results.set(name, await service.healthCheck());
    }
    return results;
    }
    }
    /**
    * API 网关
    */
    class ApiGateway {
    private routes: Map<string, Route> = new Map();
    private running: boolean = false;
    constructor(private serviceRegistry: ServiceRegistry) {}
    configure(config: any): void {
    // 配置路由
    for (const routeConfig of config.routes) {
    const route = new Route(routeConfig);
    this.routes.set(route.path, route);
    }
    }
    async start(): Promise<void> {
    this.running = true;
    console.log('API Gateway started');
    }
    async stop(): Promise<void> {
    this.running = false;
    console.log('API Gateway stopped');
    }
    /**
    * 处理请求
    */
    async handleRequest(request: Request): Promise<Response> {
    if (!this.running) {
    return {
    status: 503,
    body: 'Service Unavailable'
    };
    }
    const route = this.routes.get(request.path);
    if (!route) {
    return {
    status: 404,
    body: 'Not Found'
    };
    }
    // 转发到对应的服务
    const service = this.serviceRegistry.getService(route.service);
    if (!service) {
    return {
    status: 503,
    body: 'Service Unavailable'
    };
    }
    // 调用服务方法
    const result = await this.callService(service, route.method, request.body);
    return {
    status: 200,
    body: result
    };
    }
    private async callService(service: any, method: string, data: any): Promise<any> {
    // 根据方法调用服务
    switch (method) {
    case 'createUser':
    return await service.createUser(data);
    case 'getUser':
    return await service.getUser(data.id);
    case 'createOrder':
    return await service.createOrder(data);
    case 'getOrder':
    return await service.getOrder(data.id);
    case 'createProduct':
    return await service.createProduct(data);
    case 'getProduct':
    return await service.getProduct(data.id);
    default:
    throw new Error(`Unknown method: ${method}`);
    }
    }
    }
    /**
    * 路由
    */
    class Route {
    path: string;
    service: string;
    method: string;
    constructor(config: any) {
    this.path = config.path;
    this.service = config.service;
    this.method = config.method;
    }
    }
    /**
    * 请求
    */
    interface Request {
    path: string;
    method: string;
    body: any;
    }
    /**
    * 响应
    */
    interface Response {
    status: number;
    body: any;
    }

## 22.1.2 设计模式应用

### 1\. 工厂模式

    bash


    typescript

    // src/patterns/factory.ts

    /**
     * 工厂接口
     */
    interface ToolFactory {
      createTool(type: string): Tool;
    }

    /**
     * 具体工厂
     */
    class ConcreteToolFactory implements ToolFactory {
      createTool(type: string): Tool {
        switch (type) {
          case 'greeting':
            return new GreetingTool();
          case 'time':
            return new TimeTool();
          case 'calc':
            return new CalcTool();
          default:
            throw new Error(`Unknown tool type: ${type}`);
        }
      }
    }

    /**
     * 工具接口
     */
    interface Tool {
      execute(params: any): Promise<any>;
    }

    /**
     * 具体工具
     */
    class GreetingTool implements Tool {
      async execute(params: any): Promise<any> {
        return { greeting: `Hello, ${params.name}!` };
      }
    }

    class TimeTool implements Tool {
      async execute(params: any): Promise<any> {
        return { time: new Date().toISOString() };
      }
    }

    class CalcTool implements Tool {
      async execute(params: any): Promise<any> {
        const result = eval(params.expression);
        return { result };
      }
    }

    // 使用示例
    const factory = new ConcreteToolFactory();
    const greetingTool = factory.createTool('greeting');
    const result = await greetingTool.execute({ name: 'World' });
    console.log(result); // { greeting: 'Hello, World!' }

    ### 2. 策略模式

    // src/patterns/strategy.ts
    /**
    * 策略接口
    */
    interface DataProcessingStrategy {
    process(data: any): Promise<any>;
    }
    /**
    * 具体策略
    */
    class JsonProcessingStrategy implements DataProcessingStrategy {
    async process(data: any): Promise<any> {
    return JSON.parse(data);
    }
    }
    class XmlProcessingStrategy implements DataProcessingStrategy {
    async process(data: any): Promise<any> {
    // XML 处理逻辑
    return { xml: data };
    }
    }
    class CsvProcessingStrategy implements DataProcessingStrategy {
    async process(data: any): Promise<any> {
    // CSV 处理逻辑
    return { csv: data };
    }
    }
    /**
    * 上下文
    */
    class DataProcessor {
    private strategy: DataProcessingStrategy;
    constructor(strategy: DataProcessingStrategy) {
    this.strategy = strategy;
    }
    setStrategy(strategy: DataProcessingStrategy): void {
    this.strategy = strategy;
    }
    async processData(data: any): Promise<any> {
    return this.strategy.process(data);
    }
    }
    // 使用示例
    const processor = new DataProcessor(new JsonProcessingStrategy());
    const result1 = await processor.processData('{"name": "John"}');
    console.log(result1); // { name: 'John' }
    processor.setStrategy(new XmlProcessingStrategy());
    const result2 = await processor.processData('<name>John</name>');
    console.log(result2); // { xml: '<name>John</name>' }

### 3\. 观察者模式

    bash


    typescript

    // src/patterns/observer.ts

    /**
     * 观察者接口
     */
    interface Observer {
      update(event: Event): void;
    }

    /**
     * 被观察者接口
     */
    interface Subject {
      attach(observer: Observer): void;
      detach(observer: Observer): void;
      notify(event: Event): void;
    }

    /**
     * 具体被观察者
     */
    class EventSubject implements Subject {
      private observers: Observer[] = [];

      attach(observer: Observer): void {
        this.observers.push(observer);
      }

      detach(observer: Observer): void {
        const index = this.observers.indexOf(observer);
        if (index > -1) {
          this.observers.splice(index, 1);
        }
      }

      notify(event: Event): void {
        for (const observer of this.observers) {
          observer.update(event);
        }
      }
    }

    /**
     * 具体观察者
     */
    class LoggingObserver implements Observer {
      update(event: Event): void {
        console.log(`[Logging] Event: ${event.type}`, event.data);
      }
    }

    class MetricsObserver implements Observer {
      update(event: Event): void {
        // 记录指标
        console.log(`[Metrics] Event: ${event.type}`);
      }
    }

    class AlertObserver implements Observer {
      update(event: Event): void {
        if (event.type === 'error') {
          console.error(`[Alert] Error occurred: ${event.data.message}`);
        }
      }
    }

    // 使用示例
    const subject = new EventSubject();
    subject.attach(new LoggingObserver());
    subject.attach(new MetricsObserver());
    subject.attach(new AlertObserver());

    subject.notify({
      type: 'user.created',
      data: { userId: 1 },
      timestamp: new Date()
    });

    subject.notify({
      type: 'error',
      data: { message: 'Something went wrong' },
      timestamp: new Date()
    });

    ### 4. 装饰器模式

    // src/patterns/decorator.ts
    /**
    * 组件接口
    */
    interface Tool {
    execute(params: any): Promise<any>;
    }
    /**
    * 具体组件
    */
    class BaseTool implements Tool {
    async execute(params: any): Promise<any> {
    return { result: 'base result' };
    }
    }
    /**
    * 装饰器基类
    */
    abstract class ToolDecorator implements Tool {
    protected tool: Tool;
    constructor(tool: Tool) {
    this.tool = tool;
    }
    async execute(params: any): Promise<any> {
    return this.tool.execute(params);
    }
    }
    /**
    * 具体装饰器
    */
    class LoggingDecorator extends ToolDecorator {
    async execute(params: any): Promise<any> {
    console.log(`[Logging] Executing tool with params:`, params);
    const result = await this.tool.execute(params);
    console.log(`[Logging] Result:`, result);
    return result;
    }
    }
    class CachingDecorator extends ToolDecorator {
    private cache: Map<string, any> = new Map();
    async execute(params: any): Promise<any> {
    const cacheKey = JSON.stringify(params);
    if (this.cache.has(cacheKey)) {
    console.log(`[Cache] Cache hit for key: ${cacheKey}`);
    return this.cache.get(cacheKey);
    }
    const result = await this.tool.execute(params);
    this.cache.set(cacheKey, result);
    console.log(`[Cache] Cached result for key: ${cacheKey}`);
    return result;
    }
    }
    class RetryDecorator extends ToolDecorator {
    private maxRetries: number;
    constructor(tool: Tool, maxRetries: number = 3) {
    super(tool);
    this.maxRetries = maxRetries;
    }
    async execute(params: any): Promise<any> {
    let lastError: Error;
    for (let i = 0; i < this.maxRetries; i++) {
    try {
    return await this.tool.execute(params);
    } catch (error) {
    lastError = error;
    console.log(`[Retry] Attempt ${i + 1} failed:`, error.message);
    if (i < this.maxRetries - 1) {
    await this.delay(1000 * (i + 1));
    }
    }
    }
    throw lastError;
    }
    private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
    }
    }
    // 使用示例
    let tool: Tool = new BaseTool();
    tool = new LoggingDecorator(tool);
    tool = new CachingDecorator(tool);
    tool = new RetryDecorator(tool, 3);
    const result = await tool.execute({ param: 'value' });
    console.log(result);

### 5\. 适配器模式

    bash


    typescript

    // src/patterns/adapter.ts

    /**
     * 目标接口
     */
    interface ClaudeTool {
      execute(params: any): Promise<any>;
    }

    /**
     * 被适配者
     */
    class ExternalService {
      async callApi(endpoint: string, data: any): Promise<any> {
        // 外部服务调用
        return { endpoint, data, result: 'success' };
      }
    }

    /**
     * 适配器
     */
    class ExternalServiceAdapter implements ClaudeTool {
      constructor(private service: ExternalService) {}

      async execute(params: any): Promise<any> {
        // 将 Claude 工具参数转换为外部服务参数
        const endpoint = this.mapToEndpoint(params.action);
        const data = this.mapToData(params);

        // 调用外部服务
        const result = await this.service.callApi(endpoint, data);

        // 将外部服务结果转换为 Claude 工具结果
        return this.mapToResult(result);
      }

      private mapToEndpoint(action: string): string {
        const mapping: Record<string, string> = {
          'create': '/api/create',
          'update': '/api/update',
          'delete': '/api/delete'
        };

        return mapping[action] || '/api/default';
      }

      private mapToData(params: any): any {
        return {
          id: params.id,
          data: params.data
        };
      }

      private mapToResult(result: any): any {
        return {
          success: true,
          data: result.result
        };
      }
    }

    // 使用示例
    const service = new ExternalService();
    const adapter = new ExternalServiceAdapter(service);

    const result = await adapter.execute({
      action: 'create',
      id: 1,
      data: { name: 'John' }
    });

    console.log(result); // { success: true, data: 'success' }

```
