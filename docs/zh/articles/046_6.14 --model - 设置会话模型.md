# 6.14 --model - 设置会话模型

## 概述

`--model` 标志允许您指定 Claude Code 使用的模型。不同的模型有不同的性能、速度和成本特点，您可以根据任务需求选择合适的模型。

## 基本语法

    bash


    claude --model <模型名称>

## 可用模型


Claude 是由 Anthropic 开发的最先进的大型语言模型系列。所有当前的 Claude 模型都支持文本和图像输入、文本输出、多语言功能和视觉能力。

模型| Claude API ID| 描述| 适用场景| 相对速度| 上下文窗口
---|---|---|---|---|---

Claude Opus 4.5| `claude-opus-4-5-20251101`| 结合最大智能和实际性能的高级模型| 复杂任务、深度分析、高级代码生成| 中等| 200K 令牌
Claude Sonnet 4.5| `claude-sonnet-4-5-20250929`| 用于复杂代理和编码的智能模型，提供最佳的智能、速度和成本平衡| 一般编程任务、文档生成、代理任务| 快速| 200K 令牌 / 1M 令牌(测试版)
Claude Haiku 4.5| `claude-haiku-4-5-20251001`| 最快的模型，具有接近前沿的智能| 快速查询、简单任务、快速原型| 最快| 200K 令牌

**别名支持** ：您也可以使用更简洁的别名 `claude-opus-4-5`、`claude-sonnet-4-5` 和 `claude-haiku-4-5`，这些别名会自动指向最新的模型快照。

```bash
## 使用场景

### 1\. 复杂任务使用 Opus

    bash


    # 复杂的代码生成
    claude --model claude-opus-4-5 -p "生成一个完整的微服务架构"
    # 或使用完整模型 ID
    claude --model claude-opus-4-5-20251101 -p "生成一个完整的微服务架构"

    # 深度代码分析
    claude --model claude-opus-4-5 -p "分析这个大型项目的架构问题"

### 2\. 一般任务使用 Sonnet

    bash


    # 一般的代码编写
    claude --model claude-sonnet-4-5 -p "编写一个用户认证模块"

    # 文档生成
    claude --model claude-sonnet-4-5 -p "为这个 API 生成文档"

### 3\. 快速任务使用 Haiku

    bash


    # 快速查询
    claude --model claude-haiku-4-5 -p "这个函数是做什么的？"

    # 简单的代码修复
    claude --model claude-haiku-4-5 -p "修复这个语法错误"

## 高级用法

### 1\. 与其他标志组合

    bash


    # 指定模型 + JSON 输出
    claude --model claude-opus-4-5 --output-format json -p "分析代码"

    # 指定模型 + 限制工具
    claude --model claude-sonnet-4-5 --allowedTools "Read" "Grep" -p "搜索代码"

    # 指定模型 + 自定义系统提示
    claude --model  --system-prompt "你是一位 Python 专家" -p "编写代码"

### 2\. 根据任务类型选择模型

    bash


    #!/bin/bash
    # select-model.sh
    TASK_TYPE=$1
    case "$TASK_TYPE" in
    "complex")
    MODEL="claude-opus-4-5"
    ;;
    "general")
    MODEL="claude-sonnet-4-5"
    ;;
    "fast")
    MODEL="claude-haiku-4-5"
    ;;
    "latest")
    MODEL=""
    ;;
    *)
    MODEL="claude-sonnet-4-5"
    ;;
    esac
    echo "使用模型: $MODEL"
    claude --model "$MODEL" -p "完成任务"

### 3\. 模型性能比较

    bash


    #!/bin/bash
    # compare-models.sh

    TASK="分析这个 Python 文件的性能"

    echo "比较不同模型的性能..."

    for model in claude-haiku-4-5 claude-sonnet-4-5 claude-opus-4-5; do
        echo "测试模型: $model"
        time claude --model "$model" -p "$TASK" > "result-$model.txt"
        echo "---"
    done

    echo "性能比较完成"

### 4\. 成本优化

    bash


    #!/bin/bash
    # cost-optimization.sh
    # 根据任务复杂度选择模型
    TASK=$1
    # 简单任务使用 Haiku
    if echo "$TASK" | grep -qi "简单\|快速\|查询"; then
    MODEL="claude-haiku-4-5"
    # 复杂任务使用 Opus
    elif echo "$TASK" | grep -qi "复杂\|深度\|分析"; then
    MODEL="claude-opus-4-5"
    # 一般任务使用 Sonnet
    else
    MODEL="claude-sonnet-4-5"
    fi
    echo "使用模型: $MODEL (成本优化)"
    claude --model "$MODEL" -p "$TASK"

## 实际应用示例

### 示例 1: 分层开发

    bash


    #!/bin/bash
    # layered-development.sh

    # 第一层：快速原型（Haiku）
    echo "快速原型..."
    claude --model claude-haiku-4-5 -p "创建快速原型" > prototype.txt

    # 第二层：功能完善（Sonnet）
    echo "功能完善..."
    claude --model claude-sonnet-4-5 -p "完善原型功能" > refined.txt

    # 第三层：深度优化（Opus）
    echo "深度优化..."
    claude --model claude-opus-4-5 -p "优化性能和安全性" > optimized.txt

    echo "分层开发完成"

### 示例 2: 代码审查流程

    bash


    #!/bin/bash
    # code-review-flow.sh
    FILE=$1
    # 第一轮：快速检查（Haiku）
    echo "快速检查..."
    claude --model claude-haiku-4-5 -p "快速检查 $FILE 的语法错误" > quick-check.txt
    # 第二轮：标准审查（Sonnet）
    echo "标准审查..."
    claude --model claude-sonnet-4-5 -p "审查 $FILE 的代码质量" > standard-review.txt
    # 第三轮：深度分析（Opus）
    echo "深度分析..."
    claude --model claude-opus-4-5 -p "深度分析 $FILE 的架构和设计" > deep-analysis.txt
    echo "代码审查完成"

### 示例 3: 文档生成

    bash


    #!/bin/bash
    # generate-docs.sh

    # 生成大纲（Haiku）
    echo "生成大纲..."
    claude --model claude-haiku-4-5 -p "生成文档大纲" > outline.txt

    # 生成内容（Sonnet）
    echo "生成内容..."
    claude --model claude-sonnet-4-5 -p "生成文档内容" > content.txt

    # 完善文档（Opus）
    echo "完善文档..."
    claude --model claude-opus-4-5 -p "完善文档，添加示例和最佳实践" > final-docs.txt

    echo "文档生成完成"

### 示例 4: 测试生成

    bash


    #!/bin/bash
    # generate-tests.sh
    # 分析代码（Sonnet）
    echo "分析代码..."
    claude --model claude-sonnet-4-5 -p "分析代码结构" > analysis.txt
    # 生成测试用例（Sonnet）
    echo "生成测试用例..."
    claude --model claude-sonnet-4-5 -p "生成测试用例" > test-cases.txt
    # 生成测试代码（Opus）
    echo "生成测试代码..."
    claude --model claude-opus-4-5 -p "生成完整的测试代码" > tests.py
    echo "测试生成完成"

## 模型选择指南

### 1\. 按任务复杂度选择

```

复杂度| 推荐模型| 示例任务
---|---|---

简单| Haiku| 快速查询、简单修复
中等| Sonnet| 代码编写、文档生成
复杂| Opus| 架构设计、深度分析
最新| 3.5 Sonnet| 最新特性、深度推理

### 2\. 按性能要求选择

性能要求| 推荐模型| 说明
---|---|---

速度优先| Haiku| 最快，但能力有限
平衡| Sonnet| 速度和能力平衡
质量优先| Opus| 最强，但较慢
最新技术| 3.5 Sonnet| 最新能力，性能优秀

### 3\. 按成本考虑选择

成本考虑| 推荐模型| 说明
---|---|---

低成本| Haiku| 最便宜
中等成本| Sonnet| 性价比高
高成本| Opus| 最贵，但最强
最新成本| 3.5 Sonnet| 新模型，定价可能不同

```bash
## 最佳实践

### 1\. 从平衡模型开始

    bash


    # 默认使用 Sonnet
    claude --model claude-sonnet-4-5 -p "完成任务"

    # 如果需要更强的能力，升级到 Opus
    claude --model claude-opus-4-5 -p "完成任务"

### 2\. 根据结果调整

    bash


    #!/bin/bash
    # adaptive-model.sh
    TASK=$1
    # 先用 Sonnet 尝试
    echo "尝试使用 Sonnet..."
    claude --model claude-sonnet-4-5 -p "$TASK" > result.txt
    # 检查结果质量
    if grep -qi "无法完成\|需要更多信息" result.txt; then
    echo "升级到 Opus..."
    claude --model claude-opus-4-5 -p "$TASK" > result.txt
    fi

### 3\. 批量处理使用 Haiku

    bash


    # 批量简单任务使用 Haiku
    for file in *.py; do
        echo "处理 $file..."
        claude --model claude-haiku-4-5 -p "检查 $file 的语法" > "check-$file.txt"
    done

### 4\. 关键任务使用 Opus

    bash


    # 关键任务使用 Opus
    claude --model claude-opus-4-5 -p "生成生产环境代码"

    # 安全审查使用 Opus
    claude --model claude-opus-4-5 -p "进行安全审查"

## 常见问题

### Q1: 如何选择合适的模型？

A: 根据任务复杂度、性能要求和成本考虑选择。简单任务用 Haiku，一般任务用 Sonnet，复杂任务用 Opus。

### Q2: 可以在会话中切换模型吗？

A: 不可以。模型在会话开始时确定，整个会话使用同一个模型。

### Q3: 不同模型的价格差异大吗？

A: 是的。Opus 最贵，Haiku 最便宜。建议根据任务需求选择合适的模型。

### Q4: 3.5 Sonnet 与 3 Sonnet 有什么区别？

A: 3.5 Sonnet 是更新的模型，具有更强的能力和更好的性能，但可能定价不同。

### Q5: 如何知道哪个模型最适合我的任务？

A: 可以尝试不同的模型，比较结果质量和响应时间，选择最适合的模型。

## 与其他标志的组合示例

### 1\. 完整的开发流程

    bash


    #!/bin/bash
    # full-development.sh

    # 快速原型（Haiku）
    claude --model claude-haiku-4-5 -p "创建快速原型" > prototype.txt

    # 功能开发（Sonnet）
    claude --model claude-sonnet-4-5 -p "开发完整功能" > implementation.txt

    # 深度优化（Opus）
    claude --model claude-opus-4-5 -p "优化性能和安全性" > optimization.txt

    echo "开发流程完成"

### 2\. 迭代改进

    bash


    #!/bin/bash
    # iterative-improvement.sh
    for model in claude-haiku-4-5 claude-sonnet-4-5 claude-opus-4-5; do
    echo "使用 $model 改进..."
    claude --model "$model" -p "改进代码" > "improvement-$model.txt"
    done
    echo "迭代改进完成"

### 3\. 成本优化流程

    bash


    #!/bin/bash
    # cost-optimized-flow.sh

    # 简单任务（Haiku）
    claude --model claude-haiku-4-5 -p "快速检查" > check.txt

    # 一般任务（Sonnet）
    claude --model claude-sonnet-4-5 -p "标准开发" > dev.txt

    # 关键任务（Opus）
    claude --model claude-opus-4-5 -p "关键审查" > review.txt

    echo "成本优化流程完成"

## 总结

```

`--model` 标志提供了一种选择合适模型的方式。通过选择不同的模型，您可以：

  * 平衡性能、速度和成本
  * 根据任务复杂度选择合适的模型
  * 优化资源使用和成本
  * 获得最佳的结果质量

合理使用 `--model` 可以帮助您在不同场景下获得最佳的性能和成本效益。
